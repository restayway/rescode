package generator

import (
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// ErrorDefinition represents a single error definition from the input file.
type ErrorDefinition struct {
	Code    uint64 `json:"code" yaml:"code"`
	Key     string `json:"key" yaml:"key"`
	Message string `json:"message" yaml:"message"`
	HTTP    int    `json:"http" yaml:"http"`
	GRPC    int    `json:"grpc" yaml:"grpc"`
	Desc    string `json:"desc" yaml:"desc"`
}

// Config holds the configuration for code generation.
type Config struct {
	Package string
	Errors  []ErrorDefinition
}

// ParseInput reads and parses the input file (YAML or JSON) into error definitions.
func ParseInput(reader io.Reader, filename string) ([]ErrorDefinition, error) {
	data, err := io.ReadAll(reader)
	if err != nil {
		return nil, fmt.Errorf("failed to read input: %w", err)
	}

	var errors []ErrorDefinition
	
	// Determine format by file extension
	ext := strings.ToLower(filepath.Ext(filename))
	switch ext {
	case ".yaml", ".yml":
		if err := yaml.Unmarshal(data, &errors); err != nil {
			return nil, fmt.Errorf("failed to parse YAML: %w", err)
		}
	case ".json":
		if err := json.Unmarshal(data, &errors); err != nil {
			return nil, fmt.Errorf("failed to parse JSON: %w", err)
		}
	default:
		// Try to auto-detect by attempting JSON first, then YAML
		if err := json.Unmarshal(data, &errors); err != nil {
			if yamlErr := yaml.Unmarshal(data, &errors); yamlErr != nil {
				return nil, fmt.Errorf("failed to parse as JSON or YAML - JSON error: %v, YAML error: %v", err, yamlErr)
			}
		}
	}

	// Validate error definitions
	for i, errDef := range errors {
		if errDef.Code == 0 {
			return nil, fmt.Errorf("error definition %d: code cannot be 0", i)
		}
		if errDef.Key == "" {
			return nil, fmt.Errorf("error definition %d: key cannot be empty", i)
		}
		if errDef.Message == "" {
			return nil, fmt.Errorf("error definition %d: message cannot be empty", i)
		}
		if errDef.HTTP == 0 {
			return nil, fmt.Errorf("error definition %d: http code cannot be 0", i)
		}
		if errDef.GRPC < 0 || errDef.GRPC > 16 {
			return nil, fmt.Errorf("error definition %d: grpc code must be between 0 and 16", i)
		}
	}

	return errors, nil
}

// Generate creates Go source code from the error definitions.
func Generate(config Config) ([]byte, error) {
	if config.Package == "" {
		config.Package = "main"
	}

	var builder strings.Builder
	
	// Write package declaration
	builder.WriteString(fmt.Sprintf("// Code generated by rescodegen. DO NOT EDIT.\n\n"))
	builder.WriteString(fmt.Sprintf("package %s\n\n", config.Package))
	
	// Write imports
	builder.WriteString("import (\n")
	builder.WriteString("\t\"github.com/restayway/rescode\"\n")
	builder.WriteString("\t\"google.golang.org/grpc/codes\"\n")
	builder.WriteString(")\n\n")
	
	// Generate constants for each error
	builder.WriteString("// Error code constants\n")
	builder.WriteString("const (\n")
	for _, errDef := range config.Errors {
		builder.WriteString(fmt.Sprintf("\t%sCode uint64 = %d\n", errDef.Key, errDef.Code))
		builder.WriteString(fmt.Sprintf("\t%sHTTP int = %d\n", errDef.Key, errDef.HTTP))
		builder.WriteString(fmt.Sprintf("\t%sGRPC codes.Code = %d\n", errDef.Key, errDef.GRPC))
		builder.WriteString(fmt.Sprintf("\t%sMsg string = %q\n", errDef.Key, errDef.Message))
		if errDef.Desc != "" {
			builder.WriteString(fmt.Sprintf("\t%sDesc string = %q\n", errDef.Key, errDef.Desc))
		}
		builder.WriteString("\n")
	}
	builder.WriteString(")\n\n")
	
	// Generate factory functions
	for _, errDef := range config.Errors {
		builder.WriteString(fmt.Sprintf("// %s creates a new %s error.\n", errDef.Key, errDef.Key))
		if errDef.Desc != "" {
			builder.WriteString(fmt.Sprintf("// %s\n", errDef.Desc))
		}
		builder.WriteString(fmt.Sprintf("func %s(err ...error) *rescode.RC {\n", errDef.Key))
		builder.WriteString(fmt.Sprintf("\treturn rescode.New(%sCode, %sHTTP, %sGRPC, %sMsg)(err...)\n", 
			errDef.Key, errDef.Key, errDef.Key, errDef.Key))
		builder.WriteString("}\n\n")
	}

	// Format the generated code
	source := builder.String()
	formatted, err := format.Source([]byte(source))
	if err != nil {
		return nil, fmt.Errorf("failed to format generated code: %w", err)
	}

	return formatted, nil
}